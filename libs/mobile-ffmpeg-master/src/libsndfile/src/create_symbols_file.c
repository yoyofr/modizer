// Copyright (C) 2003-2016 Erik de Castro Lopo <erikd@mega-nerd.com>
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//	 * Redistributions of source code must retain the above copyright
//	   notice, this list of conditions and the following disclaimer.
//	 * Redistributions in binary form must reproduce the above copyright
//	   notice, this list of conditions and the following disclaimer in
//	   the documentation and/or other materials provided with the
//	   distribution.
//	 * Neither the author nor the names of any contributors may be used
//	   to endorse or promote products derived from this software without
//	   specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

//----------------------------------------------------------------
// These are all of the public functions exported from libsndfile.
//
// Its important not to change the order they are listed in or
// the ordinal values in the second column.

typedef struct
{	const char * name ;
	int			ordinal ;
} SYMBOL ;

static SYMBOL all_symbols [] =
{
	{	"sf_command",				1	},
	{	"sf_open",					2	},
	{	"sf_close",					3	},
	{	"sf_seek",					4	},
	{	"sf_error",					7	},
	{	"sf_perror",				8	},
	{	"sf_error_str",				9	},
	{	"sf_error_number",			10	},
	{	"sf_format_check",			11	},
	{	"sf_read_raw",				16	},
	{	"sf_readf_short",			17	},
	{	"sf_readf_int",				18	},
	{	"sf_readf_float",			19	},
	{	"sf_readf_double",			20	},
	{	"sf_read_short",			21	},
	{	"sf_read_int",				22	},
	{	"sf_read_float",			23	},
	{	"sf_read_double",			24	},
	{	"sf_write_raw",				32	},
	{	"sf_writef_short",			33	},
	{	"sf_writef_int",			34	},
	{	"sf_writef_float",			35	},
	{	"sf_writef_double",			36	},
	{	"sf_write_short",			37	},
	{	"sf_write_int",				38	},
	{	"sf_write_float",			39	},
	{	"sf_write_double",			40	},
	{	"sf_strerror",				50	},
	{	"sf_get_string",			60	},
	{	"sf_set_string",			61	},
	{	"sf_version_string",		68	},
	{	"sf_open_fd",				70	},
	{	"sf_wchar_open",			71	},
	{	"sf_open_virtual",			80	},
	{	"sf_write_sync",			90	},
	{	"sf_set_chunk",				100	},
	{	"sf_get_chunk_size",		101 },
	{	"sf_get_chunk_data",		102 },
	{	"sf_get_chunk_iterator",	103 },
	{	"sf_next_chunk_iterator",	104 },
	{	"sf_current_byterate",		110 },
	{	NULL,						0 }
} ;

//-------------------------------------------------------------------------------

static void
linux_symbols (FILE * file, const char * progname, const char * version)
{	unsigned k ;

	fprintf (file, "# Auto-generated by %s\n", progname) ;
	fprintf (file, "libsndfile.so.%s\n", version) ;
	fprintf (file, "{\n") ;
	fprintf (file, "  global:\n") ;

	for (k = 0 ; all_symbols [k].name != NULL ; k++)
	{	if (strcmp (all_symbols [k].name, "sf_wchar_open") == 0)
			continue ;
		fprintf (file, "	%s ;\n", all_symbols [k].name) ;
		} ;

	fprintf (file, "  local:\n") ;
	fprintf (file, "	* ;\n") ;
	fprintf (file, "} ;\n\n") ;
} /* linux_symbols */

static void
darwin_symbols (FILE * file, const char * progname)
{	unsigned k ;

	fprintf (file, "// Auto-generated by %s\n", progname) ;

	for (k = 0 ; all_symbols [k].name != NULL ; k++)
	{	if (strcmp (all_symbols [k].name, "sf_wchar_open") == 0)
			continue ;
		fprintf (file, "_%s\n", all_symbols [k].name) ;
		} ;
	fprintf (file, "\n") ;
} /* darwin_symbols */

static void
win32_symbols (FILE * file, const char * progname, const char * major_version, const char * libname)
{	unsigned k ;

	fprintf (file, "; Auto-generated by %s\n\n", progname) ;
	fprintf (file, "LIBRARY %s-%s.dll\n", libname, major_version) ;
	fprintf (file, "EXPORTS\n\n") ;

	for (k = 0 ; all_symbols [k].name != NULL ; k++)
		fprintf (file, "%-24s @%d\n", all_symbols [k].name, all_symbols [k].ordinal) ;
	fprintf (file, "\n") ;
} /* win32_symbols */

static void
os2_symbols (FILE * file, const char * progname, const char * major_version, const char * libname)
{	unsigned k ;

	fprintf (file, "; Auto-generated by %s\n\n", progname) ;
	fprintf (file, "LIBRARY %s%s\n", libname, major_version) ;
	fprintf (file, "INITINSTANCE TERMINSTANCE\n") ;
	fprintf (file, "CODE PRELOAD MOVEABLE DISCARDABLE\n") ;
	fprintf (file, "DATA PRELOAD MOVEABLE MULTIPLE NONSHARED\n") ;
	fprintf (file, "EXPORTS\n\n") ;

	for (k = 0 ; all_symbols [k].name != NULL ; k++)
	{	if (strcmp (all_symbols [k].name, "sf_wchar_open") == 0)
			continue ;
		fprintf (file, "_%-24s @%d\n", all_symbols [k].name, all_symbols [k].ordinal) ;
		} ;
	fprintf (file, "\n") ;
} /* os2_symbols */

static void
plain_symbols (FILE * file)
{	unsigned k ;

	for (k = 0 ; all_symbols [k].name != NULL ; k++)
		fprintf (file, "%s\n", all_symbols [k].name) ;
} /* plain_symbols */

static void
no_symbols (const char * os_name)
{	printf ("\n") ;
	printf ("No known way of restricting exported symbols on '%s'.\n", os_name) ;
	printf ("If you know a way, please contact the author.\n\n") ;
	exit (1) ;
} /* no_symbols */

//-------------------------------------------------------------------------------

int
main (int argc, char *argv [])
{
	FILE * file ;
	const char *cptr, *progname, *os_name, *version ;
	char major_version [256] ;
	unsigned k ;

	if ((cptr = strrchr (argv [0], '/')) != NULL)
		progname = cptr + 1 ;
	else if ((cptr = strrchr (argv [0], '\\')) != NULL)
		progname = cptr + 1 ;
	else
		progname = argv [0] ;

	if (argc != 4)
	{	printf (
			"\n"
			"Usage : %s <target OS name> <libsndfile version> <output file>.\n"
			"\n"
			"	Currently supported values for target OS are:\n"
			"		  linux\n"
			"		  darwin	 (ie MacOSX)\n"
			"		  win32	  (ie wintendo)\n"
			"		  cygwin	 (Cygwin on wintendo)\n"
			"		  os2		(OS/2)\n"
			"		  plain	  (plain list of symbols)\n"
			"\n", progname) ;
		exit (1) ;
		} ;

	os_name = argv [1] ;
	version = argv [2] ;

	strncpy (major_version, argv [2], sizeof (major_version)) ;
	for (k = 0 ; k < sizeof (major_version) ; k++)
		if (! isdigit (major_version [k]))
		{	major_version [k] = 0 ;
			break ;
			} ;

	if ((file = fopen (argv [3], "w")) == NULL)
	{	printf ("Error: Not able to open output file '%s'.\n", argv [3]) ;
		exit (1) ;
		}

	if (strcmp (os_name, "linux") == 0 || strcmp (os_name, "gnu") == 0 || strcmp (os_name, "binutils") == 0)
		linux_symbols (file, progname, version) ;
	else if (strcmp (os_name, "darwin") == 0)
		darwin_symbols (file, progname) ;
	else if (strcmp (os_name, "win32") == 0)
		win32_symbols (file, progname, major_version, "libsndfile") ;
	else if (strcmp (os_name, "os2") == 0)
		os2_symbols (file, progname, major_version, "sndfile") ;
	else if (strcmp (os_name, "static") == 0)
		plain_symbols (file) ;
	else
	{	no_symbols (os_name) ;
		fclose (file) ;
		exit (1) ;
		} ;

	fclose (file) ;

	return 0 ;
} /* main */

