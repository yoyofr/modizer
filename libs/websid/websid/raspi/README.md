# WebSid (Raspberry Pi4 edition)

This sub-project uses the base WebSid emulator as a natively compiled program on a 
Raspberry Pi 4 (RPi4). However the purpose is not to play emulated SID output  
but to instead control a real SID chip (see https://www.youtube.com/watch?v=pLZrO581B3Q ).

The SID chip is connected to the Raspberry via a somewhat improved version of 
Gianluca Ghettini's "SidBerry" design (see https://www.gianlucaghettini.net/sidberry-raspberrypi-sid-player/ ),
i.e. I am using the same GPIO pin mapping for the address & data lines. 
The audio output is generated by the real SID chip and WebSid is just used to emulate 
all the other parts of a C64 that are needed to feed the right signals to the SID chip.


My "SidBerry" device does not support read access to the SID chip (the SID chip is therefore 
hardwired to input mode). This flaw does not affect many songs (i.e. songs that read 
SID registers) and the respective output of the emulator should be good enough for 
those songs that do use it. Also it would be "impossible" on a RPi4 to feed the output of 
the SID into the emulation since the emulator would then need to match its emulation 
speed to the exact speed of the SID (see "Performance considerations" below).


Other known limitations: The current impl does not support playback of .mus files 
nor the use of ROM files (though those features could be easily added). Also multi-
SID files are not supported by the current HW configuration and related functionality 
has therefore not been tested.

Timing flaws: The SID chip on my enhanced "SidBerry board" is clocked directly via GPIO 
with the "almost" correct PAL or NTSC clock rate (depending on the song). Though this
is better than some fixed 1MHz clock the respective clock rates are still somewhat 
off - due to the Raspberry's respective clock divider limitations. Timing on the Raspberry 
side is flawed in three ways: 

1) various interrupts may delay the playback logic for short periods of time thus making 
   it impossible to always achieve the correct "micro second precision" timing. 

2) The Raspberry's "micro second counter" is driven by the ARM clock rate (700MHz-
   1500Mhz) and may be adversely affected when the Raspberry decides to dynamically 
   change the used clock rate. 

3) even if the "micro second counter" were 100% precise there is obviously a mismatch 
   to the emulated NTSC/PAL clock cycles which are somewhat shorter/longer and where 
   some rounding-errors are inevitable when timing actual writes to the SID chip. 
   Respective clock mismatches should not be noticable in most regular songs but they 
   probably add periodic disturbances to songs that rely on high-speed SID updates - 
   like certain digi-sample players do.

The above may lead to situations where a song sounds weird but when it is restarted 
it "suddenly" plays correctly.


Performance considerations: Measurements using the regular emulator on a normally 
scheduled Linux process suggest that it is fast enough to produce its output in realtime 
on one Raspberry Pi 4 CPU core: producing 20ms of output took between 7-8ms for a simple 
PSID (Lightforce.sid) and 3-12ms for an RSID (LMan - Vortex.sid). This performance still 
leaves some margin for error but it is obviously not enough leeway to integrate additional 
1MHz synchonisation directly into the emulation logic. (The measurements are an indication 
that the program might be successfully adapted to also run on slower Raspberry Pi 3 
devices - in case anyone wants to try that. If necessary, WebSid's SID chip emulation 
could here still be disabled as a performance optimization. To be run on other 
Raspberry models, in any case the "getBaseAddress" function in rpi4_utils.cpp would need 
to be adapted. Also The GPIO based clocking of the SID might not be practical on 
slower models.)

The current impl uses two CPU cores to make playback as "precise" as possible. The actual 
playback is performed by a relatively "dumb" playback-thread that runs on CPU core #3. 
The emulator-thread runs on core #2. The core #3 must be "isolated" for "exclusive" 
use by the playback thread and if the "device driver" based impl should be used, then 
CPU core #2 should be equally isolated for exclusive use by the emulator-thread. The 
playback thread just follows a sequential playback script that tells it when to write 
some SID register. Playback scripts are supplied by the emulator-thread (the main thread) 
which runs the WebSid emulator and which is not very timing critical (see performance 
considerations above).

Advanced users might peek into the "websid_module" folder for details on the "device
driver" based implementation.


todo: The idea is to eventually extend the "SidBerry" device such that the SID's
output can be directly captured on the Raspberry via some A/D converter.
todo: The simulated WebSid output is still available and it might be simultaneously 
written to some file to ease comparisons with the real SID signal.



## Howto use

1) use a RPi4 with a suitably tuned Raspberry OS; impl is currently NOT adapted 
   to older models (rpi4_utils.cpp must first be adapted for other models). You
   may find information that served me well when setting up my RPi4 here:
   https://jwothke.wordpress.com/2021/04/14/raspberry-pi-4-setup-notes/
   
2) The player can be run on a stock Raspberry OS, but the various things that
   go on by default will significantly disturb the playback timing. To minimize
   respective disturbances the following tuning should be applied to the used
   Linux kernel (see "make menuconfig"): enable the "NO_HZ_FULL" option via  
   the respective feature in the configurator: "Timer tick handling" => "Full
   dynaticks system (tickless)". Compile and install that kernel. Then add
   the following to the beginning of /boot/cmdline.txt (the RPi4 must
   be rebooted after that change): isolcpus=2,3 rcu_nocbs=2,3 rcu_nocb_poll=2,3 nohz_full=2,3 
   These options will effectively "isolate" the CPU cores #2 & #3 from any normal use
   by the OS.(Please let me know if you find some configuration that
   works even better..)
   
3) preferably the RPi4 should boot into plain shell mode with as little extra 
   tasks (e.g. no desktop) running as possible (at least that's how I tested)

4) start the player using sudo, e.g. "sudo ./websid somesong.sid" (see 
   "websid_module" folder for advanced options)

5) playback can be interrupted by pressing ctrl-C
   
   
## Dependencies

The player comes bundled with a stripped down version of "Wiring Pi". And for use on 
the RPi4B no additional libs are needed.

In principle a regular version of "Wiring Pi" (see https://github.com/WiringPi/WiringPi) 
could be used just as well (which might be useful when migrating the code to a 
different Raspberry model). see Makefile for respective information.


## License
Terms of Use: This software is licensed under a CC BY-NC-SA 
(http://creativecommons.org/licenses/by-nc-sa/4.0/)
