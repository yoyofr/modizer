/*
* This is the interface for using the actual emulator.
*
* This updated implementation uses a cycle-by-cycle emulation of the different
* C64 components (VIC, SID, CIA, CPU).
*
* PSID files are wrapped with respective driver code so that the regular
* RSID emulation can be used.
*
* Note: It is still a somewhat high level emulation, i.e. unlike very precise
* emulators it does NOT emulate different phases of a system clock cycle, nor
* respective detailed internal workings of all the various components (e.g. CPU).
*
* WebSid (c) 2019 Jürgen Wothke
* version 0.94
*
* Terms of Use: This software is licensed under a CC BY-NC-SA
* (http://creativecommons.org/licenses/by-nc-sa/4.0/).
*/

#include <string.h>
#include <stdio.h>
#include <math.h>

#ifdef EMSCRIPTEN
#include <emscripten.h>
#endif

#include "core.h"

extern "C" {
#include "system.h"
#include "memory.h"
#include "cpu.h"
#include "vic.h"
#include "cia.h"
#include "hacks.h"
}
#include "sid.h"
#include "loaders.h"

//TODO:  MODIZER changes start / YOYOFR
extern "C" {
#include "../../../../src/ModizerVoicesData.h"
}
//TODO:  MODIZER changes end / YOYOFR

// the clocks used in the emulation do not usually match the used audio
// output sample rate and fractional overflows are handled here:
static double _sample_cycles;

static void resetDefaults(uint32_t sample_rate, uint8_t is_rsid,
							uint8_t is_ntsc, uint8_t is_compatible) {
	sysReset();
	cpuInit(is_rsid);

    memResetIO();

	ciaReset(is_rsid, is_ntsc);
	vicReset(is_rsid, is_ntsc);

	uint32_t clock_rate= sysGetClockRate(is_ntsc);
	SID::resetAll(sample_rate, clock_rate, is_rsid, is_compatible);

	_sample_cycles= 0;
}

#ifdef TEST
// ------------------ to run Wolfgang Lorenz's test-suite ---------------------

extern uint8_t test_running;

void testInit(void)
{
	memRestoreSnapshot();
	resetDefaults(44100, 1, 0, 1);
}

void Core::rsidRunTest() {
	testInit();

	// use same sequence as in runEmulation (just without generating sample output)
	while(test_running) {
		if(!sysClockTest()) {
			test_running= 0;
		}
	}
}
#endif

void runEmulation(uint8_t is_simple_sid_mode, int16_t* synth_buffer,
					int16_t** synth_trace_bufs, uint16_t samples_per_call) {

	double n= SID::getCyclesPerSample();

	// trivia: The system clock rate (and others) is generated by the VIC
	// and feed to the CPU's ϕ1 pin. The CPU pin that then outputs the system
	// clock rate for use by other components is called Phase 2 or Phi2 (ϕ2).

	// VIC always uses the 1st phase of each ϕ2 clock cycle (for bus access)
	// so it should be clocked first.

	// performance info: JavaScript performance.now() measurements with a 8SID
	// song suggest that only a small fraction of the overall runtime is spent
	// in the SID::synth*() and most of the time is spent in the earlier
	// clock-by-clock emulation of the system components; 2 (5) vs 12 (21)


	if (SID::getNumberUsedChips() == 1) {

		// most relevant case.. only one SID
		for (int i= 0; i<samples_per_call; i++) {
			while(_sample_cycles < n) {
				// clocking used for "normal" songs". note: for a slow garbage song
				// like Baroque_Music_64_BASIC the sysClockOpt()/SID::isAudible()  bring down
				// the "silence detection" from 33 sec to 19 secs

				sysClockOpt();
				_sample_cycles++;
			}
			_sample_cycles -= n;	// keep overflow

			SID::synthSamplesSingleSID(synth_buffer, synth_trace_bufs, i);
		}
	} else {

		if (is_simple_sid_mode) {
			// standard sid-file mode, for 2 and 3 SID configurations

			for (int i= 0; i<samples_per_call; i++) {
				while(_sample_cycles < n) {
					sysClockOpt();
                    //_sample_cycles++; //YOYOFR
                    if (mdz_ratio_fp_inc) _sample_cycles+=(double)mdz_ratio_fp_inc/65536.0;
                    else _sample_cycles++;
				}
				_sample_cycles -= n;	// keep overflow

				SID::synthSamplesMultiSID(synth_buffer, synth_trace_bufs, i);
			}

		} else {
			// extended multi-sid mode for up to 10 SIDs (for performance reasons
			// the "scope" handling here is stripped down to a less expensive impl)

			for (int i= 0; i<samples_per_call; i++) {
				while(_sample_cycles < n) {
					sysClock();
                    //_sample_cycles++; //YOYOFR
                    if (mdz_ratio_fp_inc) _sample_cycles+=(double)mdz_ratio_fp_inc/65536.0;
                    else _sample_cycles++;
				}
				_sample_cycles -= n;	// keep overflow

				SID::synthSamplesStrippedMultiSID(synth_buffer, synth_trace_bufs, i);
			}
		}
	}
}

// XXX bad API design.. the batch size is actually controlled by samples_per_call and it may
// result in more or less than "one frame". the below 1x per frame hacks obviously will not work anymore..
uint8_t Core::runOneFrame(uint8_t is_simple_sid_mode, uint8_t speed, int16_t* synth_buffer,
							int16_t** synth_trace_bufs, uint16_t samples_per_call) {

	SID::resetGlobalStatistics();

	ciaUpdateTOD(speed); // hack: TOD is rarely used so there is no point to do it more precisely

	runEmulation(is_simple_sid_mode, synth_buffer, synth_trace_bufs, samples_per_call);

	return 0;
}

void Core::loadSongBinary(uint8_t* src, uint16_t dest_addr, uint16_t len, uint8_t basic_mode) {
	memCopyToRAM(src, dest_addr, len);

	if (basic_mode) {
		memSetupBASIC(len);
	}

	memSaveSnapshot();
}

uint8_t runSubroutineTilEnd() {
	while (cpuIsValidPcPSID()) {
		if (!sysClockTimeout()) return 0;
	}
	return 1;
}

void Core::callKernalROMReset() {
	// regular "kernal ROM" based RESET provides most of the environment
	// needed for BASIC programs. precondition: RSID mode; standard
	// kernal & basic ROMs must be available

	resetDefaults(44100, 1, 0, 1);	// dummy settings good enough for RESET

	sysReset();

	// note: it might be a good idea to strip down the standard ROM impl
	// which unnecessarily wastes many cycles for useless RAM tests, etc
	uint16_t rom_routine = 0xFCE2;
	cpuSetProgramCounter(rom_routine, 0);

	runSubroutineTilEnd();

	// note: the used ROM might not match the song's settings (e.g. PAL/NTSC)
	// and the respective memory snapshot that is taken on the above base may
	// be flawed. But that doesn't matter since timing specific settings are
	// always reset before playing a sub-tune.
}

uint8_t runInitPSID(uint16_t init_addr, uint8_t selected_track) {
	// run the the PSID's "INIT" subroutine separately so that the "bank"
	// setting can be handled here on the C/C++ side

	sysReset();
	cpuSetProgramCounter(init_addr, selected_track);	// set starting point for emulation

	cpuIrqFlagPSID(1);	// block IRQ during INIT

	if (!runSubroutineTilEnd()) return 0;

	cpuIrqFlagPSID(0);

	return 1;
}

void Core::startupTune(uint32_t sample_rate, uint8_t selected_track,
						uint8_t is_rsid, uint8_t is_timer_driven_psid, uint8_t is_ntsc,
						uint8_t is_compatible, uint8_t basic_mode,
						uint16_t free_space, uint16_t* init_addr, uint16_t load_end_addr,
						uint16_t play_addr) {

	resetDefaults(sample_rate, is_rsid, is_ntsc, is_compatible);

	memRestoreSnapshot();	// previous sub-tune run may have corrupted the RAM
	hackIfNeeded((*init_addr));

	memSetDefaultBanksPSID(is_rsid, (*init_addr), load_end_addr);	// PSID crap

	if (!is_rsid) {

		if (!runInitPSID((*init_addr), selected_track)) return;

		uint16_t main = memPsidMain(free_space, play_addr);
		cpuSetProgramCounterPSID(main);	// just install an endless loop for main

		ciaSetDefaultsPSID(is_timer_driven_psid);
		vicSetDefaultsPSID(is_timer_driven_psid);

	} else {
		memRsidInit(free_space, init_addr, selected_track, basic_mode);
        
		sysReset();        
		cpuSetProgramCounter((*init_addr), selected_track);
	}
}

void Core::resetTimings(uint32_t sample_rate, uint8_t is_ntsc) {
	vicSetModel(is_ntsc);	// see for timing details

	uint32_t clock_rate= 	sysGetClockRate(is_ntsc);
	uint8_t is_rsid=		FileLoader::isRSID();
	uint8_t is_compatible=	FileLoader::getCompatibility();

	SID::resetAll(sample_rate, clock_rate, is_rsid, is_compatible);
}
